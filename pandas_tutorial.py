# -*- coding: utf-8 -*-
"""Pandas_Tutorial

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dtXcsNl53CHTrfQfMFubcfXRRvChoduT

Pandas Basics
"""

import numpy as np
import pandas as pd

# Import Canada Imigration Dataset

url = "https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-DV0101EN-SkillsNetwork/Data%20Files/Canada.xlsx"
df_canada = pd.read_excel(url, sheet_name='Canada by Citizenship',
        skiprows=range(20),
        skipfooter=2)
print("Data read into a pandas dataframe!")

# tip: You can specify the number of rows you'd like to see as follows: df_can.head(10) 
df_canada.head()

# Veiw the bottom 5 rows of the dataset using the tail() function.

df_canada.tail()

# Getting basic information about your dataframe.

df_canada.info(verbose=False)

# To get the list of column headers 

df_canada.columns.values

# To get the list of indicies

df_canada.index.values

# The default type of index and columns is NOT list.

print(type(df_canada.columns))
print(type(df_canada.index))

# To get the index and columns as lists

df_canada.columns.tolist()
df_canada.index.tolist()

print (type(df_canada.columns.tolist()))
print (type(df_canada.index.tolist()))

# To view the dimensions of the dataframe

# size of dataframe (rows, columns)

df_canada.shape

# Note: The main types stored in pandas objects are float, int, bool, datetime64[ns] and datetime64[ns, tz] (in >= 0.17.0), timedelta[ns],
# category (in >= 0.15.0), and object (string). In addition these dtypes have item sizes, e.g. int64 and int32.

# Clean the data set to remove a few unnecessary columns

# df_canada.drop(['AREA','REG','DEV','Type','Coverage'],axis=1, inplace=True )
df_canada.head(2)

# Rename the columns so that they make sense

df_canada.rename(columns={'OdName':'Country', 'AreaName':'Continent', 'RegName':'Region'}, inplace=True)
df_canada.columns

#  Add a 'Total' column that sums up the total immigrants by country over the entire period 1980 - 2013

df_canada["Total"] = df_canada.sum(axis=1)

# Check to see how many null objects we have in the dataset 

df_canada.isnull().sum()

# View a quick summary of each column in dataframe

df_canada.describe()

# Select Column

# Method 1: Quick and easy, but only works if the column name does NOT have spaces or special characters.

df_canada.Country  # returns a series


# Method 2: More robust, and can filter on multiple columns.

df_canada[['Country', 1980, 1981, 1982, 1983, 1984, 1985]] # returns a dataframe
# notice that 'Country' is string, and the years are integers. 
# for the sake of consistency, we will convert all column names to string later on.

# Select Row

"""
There are main 3 ways to select rows:

    df.loc[label]        
        #filters by the labels of the index/column
    df.iloc[index]       
        #filters by the positions of the index/column

Before we proceed, notice that the defaul index of the dataset is a numeric range from 0 to 194. 
This makes it very difficult to do a query by a specific country. For example to search for data on Japan,
we need to know the corressponding index value.
"""

# This can be fixed very easily by setting the 'Country' column as the index

df_canada.set_index('Country', inplace=True)
# tip: The opposite of set is reset. So to reset the index, we can use df_can.reset_index()

df_canada.head(3)

# optional: to remove the name of the index
df_canada.index.name = None

"""Example: Let's view the number of immigrants from Japan (row 87) for the following scenarios:

1. The full row data (all columns)
2. For year 2013
3. For years 1980 to 1985
"""

# 1. the full row data (all columns)
print(df_canada.loc['Japan'])

# alternate methods
print(df_canada.iloc[87])
print(df_canada[df_canada.index == 'Japan'].T.squeeze())

# 2. for year 2013
print(df_canada.loc['Japan', 2013])

# alternate method
print(df_canada.iloc[87, 36]) # year 2013 is the last column, with a positional index of 36

# 3. for years 1980 to 1985
print(df_canada.loc['Japan', [1980, 1981, 1982, 1983, 1984, 1984]])
print(df_canada.iloc[87, [3, 4, 5, 6, 7, 8]])

# To avoid this ambuigity, let's convert the column names into strings: '1980' to '2013'.


df_canada.columns = list(map(str, df_canada.columns))
# [print (type(x)) for x in df_can.columns.values] #<-- uncomment to check type of column headers

# Since we converted the years to string, let's declare a variable that will allow us to easily call upon the full range of years:

# useful for plotting later on
years = list(map(str, range(1980, 2014)))
years

"""Filtering based on a criteria

To filter the dataframe based on a condition, we simply pass the condition as a boolean vector.

For example, Let's filter the dataframe to show the data on Asian countries (AreaName = Asia).

"""

# 1. create the condition boolean series
condition = df_canada['Continent'] == 'Asia'
print(condition)

# 2. pass this condition into the dataFrame
df_canada[condition]

# we can pass mutliple criteria in the same line. 
# let's filter for AreaNAme = Asia and RegName = Southern Asia

df_canada[(df_canada['Continent']=='Asia') & (df_canada['Region']=='Southern Asia')]

# note: When using 'and' and 'or' operators, pandas requires we use '&' and '|' instead of 'and' and 'or'
# don't forget to enclose the two conditions in parentheses

# Review the changes we have made to our dataframe

print('data dimensions:', df_canada.shape)
print(df_canada.columns)
df_canada.head(2)